var ChatProtocol = (function (exports) {
    'use strict';

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
    /**
     * A private implementation of Pipeline.
     * Do not export this class from the package.
     * @internal
     */
    class HttpPipeline {
        constructor(policies) {
            var _a;
            this._policies = [];
            this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];
            this._orderedPolicies = undefined;
        }
        addPolicy(policy, options = {}) {
            if (options.phase && options.afterPhase) {
                throw new Error("Policies inside a phase cannot specify afterPhase.");
            }
            if (options.phase && !ValidPhaseNames.has(options.phase)) {
                throw new Error(`Invalid phase name: ${options.phase}`);
            }
            if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
                throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
            }
            this._policies.push({
                policy,
                options,
            });
            this._orderedPolicies = undefined;
        }
        removePolicy(options) {
            const removedPolicies = [];
            this._policies = this._policies.filter((policyDescriptor) => {
                if ((options.name && policyDescriptor.policy.name === options.name) ||
                    (options.phase && policyDescriptor.options.phase === options.phase)) {
                    removedPolicies.push(policyDescriptor.policy);
                    return false;
                }
                else {
                    return true;
                }
            });
            this._orderedPolicies = undefined;
            return removedPolicies;
        }
        sendRequest(httpClient, request) {
            const policies = this.getOrderedPolicies();
            const pipeline = policies.reduceRight((next, policy) => {
                return (req) => {
                    return policy.sendRequest(req, next);
                };
            }, (req) => httpClient.sendRequest(req));
            return pipeline(request);
        }
        getOrderedPolicies() {
            if (!this._orderedPolicies) {
                this._orderedPolicies = this.orderPolicies();
            }
            return this._orderedPolicies;
        }
        clone() {
            return new HttpPipeline(this._policies);
        }
        static create() {
            return new HttpPipeline();
        }
        orderPolicies() {
            /**
             * The goal of this method is to reliably order pipeline policies
             * based on their declared requirements when they were added.
             *
             * Order is first determined by phase:
             *
             * 1. Serialize Phase
             * 2. Policies not in a phase
             * 3. Deserialize Phase
             * 4. Retry Phase
             * 5. Sign Phase
             *
             * Within each phase, policies are executed in the order
             * they were added unless they were specified to execute
             * before/after other policies or after a particular phase.
             *
             * To determine the final order, we will walk the policy list
             * in phase order multiple times until all dependencies are
             * satisfied.
             *
             * `afterPolicies` are the set of policies that must be
             * executed before a given policy. This requirement is
             * considered satisfied when each of the listed policies
             * have been scheduled.
             *
             * `beforePolicies` are the set of policies that must be
             * executed after a given policy. Since this dependency
             * can be expressed by converting it into a equivalent
             * `afterPolicies` declarations, they are normalized
             * into that form for simplicity.
             *
             * An `afterPhase` dependency is considered satisfied when all
             * policies in that phase have scheduled.
             *
             */
            const result = [];
            // Track all policies we know about.
            const policyMap = new Map();
            function createPhase(name) {
                return {
                    name,
                    policies: new Set(),
                    hasRun: false,
                    hasAfterPolicies: false,
                };
            }
            // Track policies for each phase.
            const serializePhase = createPhase("Serialize");
            const noPhase = createPhase("None");
            const deserializePhase = createPhase("Deserialize");
            const retryPhase = createPhase("Retry");
            const signPhase = createPhase("Sign");
            // a list of phases in order
            const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
            // Small helper function to map phase name to each Phase
            function getPhase(phase) {
                if (phase === "Retry") {
                    return retryPhase;
                }
                else if (phase === "Serialize") {
                    return serializePhase;
                }
                else if (phase === "Deserialize") {
                    return deserializePhase;
                }
                else if (phase === "Sign") {
                    return signPhase;
                }
                else {
                    return noPhase;
                }
            }
            // First walk each policy and create a node to track metadata.
            for (const descriptor of this._policies) {
                const policy = descriptor.policy;
                const options = descriptor.options;
                const policyName = policy.name;
                if (policyMap.has(policyName)) {
                    throw new Error("Duplicate policy names not allowed in pipeline");
                }
                const node = {
                    policy,
                    dependsOn: new Set(),
                    dependants: new Set(),
                };
                if (options.afterPhase) {
                    node.afterPhase = getPhase(options.afterPhase);
                    node.afterPhase.hasAfterPolicies = true;
                }
                policyMap.set(policyName, node);
                const phase = getPhase(options.phase);
                phase.policies.add(node);
            }
            // Now that each policy has a node, connect dependency references.
            for (const descriptor of this._policies) {
                const { policy, options } = descriptor;
                const policyName = policy.name;
                const node = policyMap.get(policyName);
                if (!node) {
                    throw new Error(`Missing node for policy ${policyName}`);
                }
                if (options.afterPolicies) {
                    for (const afterPolicyName of options.afterPolicies) {
                        const afterNode = policyMap.get(afterPolicyName);
                        if (afterNode) {
                            // Linking in both directions helps later
                            // when we want to notify dependants.
                            node.dependsOn.add(afterNode);
                            afterNode.dependants.add(node);
                        }
                    }
                }
                if (options.beforePolicies) {
                    for (const beforePolicyName of options.beforePolicies) {
                        const beforeNode = policyMap.get(beforePolicyName);
                        if (beforeNode) {
                            // To execute before another node, make it
                            // depend on the current node.
                            beforeNode.dependsOn.add(node);
                            node.dependants.add(beforeNode);
                        }
                    }
                }
            }
            function walkPhase(phase) {
                phase.hasRun = true;
                // Sets iterate in insertion order
                for (const node of phase.policies) {
                    if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
                        // If this node is waiting on a phase to complete,
                        // we need to skip it for now.
                        // Even if the phase is empty, we should wait for it
                        // to be walked to avoid re-ordering policies.
                        continue;
                    }
                    if (node.dependsOn.size === 0) {
                        // If there's nothing else we're waiting for, we can
                        // add this policy to the result list.
                        result.push(node.policy);
                        // Notify anything that depends on this policy that
                        // the policy has been scheduled.
                        for (const dependant of node.dependants) {
                            dependant.dependsOn.delete(node);
                        }
                        policyMap.delete(node.policy.name);
                        phase.policies.delete(node);
                    }
                }
            }
            function walkPhases() {
                for (const phase of orderedPhases) {
                    walkPhase(phase);
                    // if the phase isn't complete
                    if (phase.policies.size > 0 && phase !== noPhase) {
                        if (!noPhase.hasRun) {
                            // Try running noPhase to see if that unblocks this phase next tick.
                            // This can happen if a phase that happens before noPhase
                            // is waiting on a noPhase policy to complete.
                            walkPhase(noPhase);
                        }
                        // Don't proceed to the next phase until this phase finishes.
                        return;
                    }
                    if (phase.hasAfterPolicies) {
                        // Run any policies unblocked by this phase
                        walkPhase(noPhase);
                    }
                }
            }
            // Iterate until we've put every node in the result list.
            let iteration = 0;
            while (policyMap.size > 0) {
                iteration++;
                const initialResultLength = result.length;
                // Keep walking each phase in order until we can order every node.
                walkPhases();
                // The result list *should* get at least one larger each time
                // after the first full pass.
                // Otherwise, we're going to loop forever.
                if (result.length <= initialResultLength && iteration > 1) {
                    throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
                }
            }
            return result;
        }
    }
    /**
     * Creates a totally empty pipeline.
     * Useful for testing or creating a custom one.
     */
    function createEmptyPipeline() {
        return HttpPipeline.create();
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    function log(...args) {
        if (args.length > 0) {
            const firstArg = String(args[0]);
            if (firstArg.includes(":error")) {
                console.error(...args);
            }
            else if (firstArg.includes(":warning")) {
                console.warn(...args);
            }
            else if (firstArg.includes(":info")) {
                console.info(...args);
            }
            else if (firstArg.includes(":verbose")) {
                console.debug(...args);
            }
            else {
                console.debug(...args);
            }
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const debugEnvVariable = (typeof process !== "undefined" && process.env && process.env.DEBUG) || undefined;
    let enabledString;
    let enabledNamespaces = [];
    let skippedNamespaces = [];
    const debuggers = [];
    if (debugEnvVariable) {
        enable(debugEnvVariable);
    }
    const debugObj = Object.assign((namespace) => {
        return createDebugger(namespace);
    }, {
        enable,
        enabled,
        disable,
        log,
    });
    function enable(namespaces) {
        enabledString = namespaces;
        enabledNamespaces = [];
        skippedNamespaces = [];
        const wildcard = /\*/g;
        const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
        for (const ns of namespaceList) {
            if (ns.startsWith("-")) {
                skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
            }
            else {
                enabledNamespaces.push(new RegExp(`^${ns}$`));
            }
        }
        for (const instance of debuggers) {
            instance.enabled = enabled(instance.namespace);
        }
    }
    function enabled(namespace) {
        if (namespace.endsWith("*")) {
            return true;
        }
        for (const skipped of skippedNamespaces) {
            if (skipped.test(namespace)) {
                return false;
            }
        }
        for (const enabledNamespace of enabledNamespaces) {
            if (enabledNamespace.test(namespace)) {
                return true;
            }
        }
        return false;
    }
    function disable() {
        const result = enabledString || "";
        enable("");
        return result;
    }
    function createDebugger(namespace) {
        const newDebugger = Object.assign(debug, {
            enabled: enabled(namespace),
            destroy,
            log: debugObj.log,
            namespace,
            extend,
        });
        function debug(...args) {
            if (!newDebugger.enabled) {
                return;
            }
            if (args.length > 0) {
                args[0] = `${namespace} ${args[0]}`;
            }
            newDebugger.log(...args);
        }
        debuggers.push(newDebugger);
        return newDebugger;
    }
    function destroy() {
        const index = debuggers.indexOf(this);
        if (index >= 0) {
            debuggers.splice(index, 1);
            return true;
        }
        return false;
    }
    function extend(namespace) {
        const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
        newDebugger.log = this.log;
        return newDebugger;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const registeredLoggers = new Set();
    const logLevelFromEnv = (typeof process !== "undefined" && process.env && process.env.TYPESPEC_RUNTIME_LOG_LEVEL) ||
        undefined;
    let typeSpecRuntimeLogLevel;
    /**
     * The TypeSpecRuntimeLogger provides a mechanism for overriding where logs are output to.
     * By default, logs are sent to stderr.
     * Override the `log` method to redirect logs to another location.
     */
    const TypeSpecRuntimeLogger = debugObj("typeSpecRuntime");
    TypeSpecRuntimeLogger.log = (...args) => {
        debugObj.log(...args);
    };
    const TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    if (logLevelFromEnv) {
        // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
        if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
            setLogLevel(logLevelFromEnv);
        }
        else {
            console.error(`TYPESPEC_RUNTIME_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
        }
    }
    /**
     * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.
     * @param level - The log level to enable for logging.
     * Options from most verbose to least verbose are:
     * - verbose
     * - info
     * - warning
     * - error
     */
    function setLogLevel(level) {
        if (level && !isTypeSpecRuntimeLogLevel(level)) {
            throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
        }
        typeSpecRuntimeLogLevel = level;
        const enabledNamespaces = [];
        for (const logger of registeredLoggers) {
            if (shouldEnable(logger)) {
                enabledNamespaces.push(logger.namespace);
            }
        }
        debugObj.enable(enabledNamespaces.join(","));
    }
    const levelMap = {
        verbose: 400,
        info: 300,
        warning: 200,
        error: 100,
    };
    /**
     * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.
     * @param namespace - The name of the SDK package.
     * @hidden
     */
    function createClientLogger(namespace) {
        const clientRootLogger = TypeSpecRuntimeLogger.extend(namespace);
        patchLogMethod(TypeSpecRuntimeLogger, clientRootLogger);
        return {
            error: createLogger(clientRootLogger, "error"),
            warning: createLogger(clientRootLogger, "warning"),
            info: createLogger(clientRootLogger, "info"),
            verbose: createLogger(clientRootLogger, "verbose"),
        };
    }
    function patchLogMethod(parent, child) {
        child.log = (...args) => {
            parent.log(...args);
        };
    }
    function createLogger(parent, level) {
        const logger = Object.assign(parent.extend(level), {
            level,
        });
        patchLogMethod(parent, logger);
        if (shouldEnable(logger)) {
            const enabledNamespaces = debugObj.disable();
            debugObj.enable(enabledNamespaces + "," + logger.namespace);
        }
        registeredLoggers.add(logger);
        return logger;
    }
    function shouldEnable(logger) {
        return Boolean(typeSpecRuntimeLogLevel && levelMap[logger.level] <= levelMap[typeSpecRuntimeLogLevel]);
    }
    function isTypeSpecRuntimeLogLevel(logLevel) {
        return TYPESPEC_RUNTIME_LOG_LEVELS.includes(logLevel);
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const logger = createClientLogger("ts-http-runtime");

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Helper to determine when an input is a generic JS object.
     * @returns true when input is an object type that is not null, Array, RegExp, or Date.
     */
    function isObject(input) {
        return (typeof input === "object" &&
            input !== null &&
            !Array.isArray(input) &&
            !(input instanceof RegExp) &&
            !(input instanceof Date));
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const RedactedString = "REDACTED";
    // Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts
    const defaultAllowedHeaderNames = [
        "x-ms-client-request-id",
        "x-ms-return-client-request-id",
        "x-ms-useragent",
        "x-ms-correlation-request-id",
        "x-ms-request-id",
        "client-request-id",
        "ms-cv",
        "return-client-request-id",
        "traceparent",
        "Access-Control-Allow-Credentials",
        "Access-Control-Allow-Headers",
        "Access-Control-Allow-Methods",
        "Access-Control-Allow-Origin",
        "Access-Control-Expose-Headers",
        "Access-Control-Max-Age",
        "Access-Control-Request-Headers",
        "Access-Control-Request-Method",
        "Origin",
        "Accept",
        "Accept-Encoding",
        "Cache-Control",
        "Connection",
        "Content-Length",
        "Content-Type",
        "Date",
        "ETag",
        "Expires",
        "If-Match",
        "If-Modified-Since",
        "If-None-Match",
        "If-Unmodified-Since",
        "Last-Modified",
        "Pragma",
        "Request-Id",
        "Retry-After",
        "Server",
        "Transfer-Encoding",
        "User-Agent",
        "WWW-Authenticate",
    ];
    const defaultAllowedQueryParameters = ["api-version"];
    /**
     * @internal
     */
    class Sanitizer {
        constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [], } = {}) {
            allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
            allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
            this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
            this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
        }
        sanitize(obj) {
            const seen = new Set();
            return JSON.stringify(obj, (key, value) => {
                // Ensure Errors include their interesting non-enumerable members
                if (value instanceof Error) {
                    return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
                }
                if (key === "headers") {
                    return this.sanitizeHeaders(value);
                }
                else if (key === "url") {
                    return this.sanitizeUrl(value);
                }
                else if (key === "query") {
                    return this.sanitizeQuery(value);
                }
                else if (key === "body") {
                    // Don't log the request body
                    return undefined;
                }
                else if (key === "response") {
                    // Don't log response again
                    return undefined;
                }
                else if (key === "operationSpec") {
                    // When using sendOperationRequest, the request carries a massive
                    // field with the autorest spec. No need to log it.
                    return undefined;
                }
                else if (Array.isArray(value) || isObject(value)) {
                    if (seen.has(value)) {
                        return "[Circular]";
                    }
                    seen.add(value);
                }
                return value;
            }, 2);
        }
        sanitizeUrl(value) {
            if (typeof value !== "string" || value === null) {
                return value;
            }
            const url = new URL(value);
            if (!url.search) {
                return value;
            }
            for (const [key] of url.searchParams) {
                if (!this.allowedQueryParameters.has(key.toLowerCase())) {
                    url.searchParams.set(key, RedactedString);
                }
            }
            return url.toString();
        }
        sanitizeHeaders(obj) {
            const sanitized = {};
            for (const key of Object.keys(obj)) {
                if (this.allowedHeaderNames.has(key.toLowerCase())) {
                    sanitized[key] = obj[key];
                }
                else {
                    sanitized[key] = RedactedString;
                }
            }
            return sanitized;
        }
        sanitizeQuery(value) {
            if (typeof value !== "object" || value === null) {
                return value;
            }
            const sanitized = {};
            for (const k of Object.keys(value)) {
                if (this.allowedQueryParameters.has(k.toLowerCase())) {
                    sanitized[k] = value[k];
                }
                else {
                    sanitized[k] = RedactedString;
                }
            }
            return sanitized;
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * The programmatic identifier of the logPolicy.
     */
    const logPolicyName = "logPolicy";
    /**
     * A policy that logs all requests and responses.
     * @param options - Options to configure logPolicy.
     */
    function logPolicy(options = {}) {
        var _a;
        const logger$1 = (_a = options.logger) !== null && _a !== void 0 ? _a : logger.info;
        const sanitizer = new Sanitizer({
            additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
            additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,
        });
        return {
            name: logPolicyName,
            async sendRequest(request, next) {
                if (!logger$1.enabled) {
                    return next(request);
                }
                logger$1(`Request: ${sanitizer.sanitize(request)}`);
                const response = await next(request);
                logger$1(`Response status code: ${response.status}`);
                logger$1(`Headers: ${sanitizer.sanitize(response.headers)}`);
                return response;
            },
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * The programmatic identifier of the redirectPolicy.
     */
    const redirectPolicyName = "redirectPolicy";
    /**
     * Methods that are allowed to follow redirects 301 and 302
     */
    const allowedRedirect = ["GET", "HEAD"];
    /**
     * A policy to follow Location headers from the server in order
     * to support server-side redirection.
     * In the browser, this policy is not used.
     * @param options - Options to control policy behavior.
     */
    function redirectPolicy(options = {}) {
        const { maxRetries = 20 } = options;
        return {
            name: redirectPolicyName,
            async sendRequest(request, next) {
                const response = await next(request);
                return handleRedirect(next, response, maxRetries);
            },
        };
    }
    async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
        const { request, status, headers } = response;
        const locationHeader = headers.get("location");
        if (locationHeader &&
            (status === 300 ||
                (status === 301 && allowedRedirect.includes(request.method)) ||
                (status === 302 && allowedRedirect.includes(request.method)) ||
                (status === 303 && request.method === "POST") ||
                status === 307) &&
            currentRetries < maxRetries) {
            const url = new URL(locationHeader, request.url);
            request.url = url.toString();
            // POST request with Status code 303 should be converted into a
            // redirected GET request if the redirect url is present in the location header
            if (status === 303) {
                request.method = "GET";
                request.headers.delete("Content-Length");
                delete request.body;
            }
            request.headers.delete("Authorization");
            const res = await next(request);
            return handleRedirect(next, res, maxRetries, currentRetries + 1);
        }
        return response;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /*
     * NOTE: When moving this file, please update "browser" section in package.json.
     */
    /**
     * @internal
     */
    function getHeaderName() {
        return "x-ms-useragent";
    }
    /**
     * @internal
     */
    function setPlatformSpecificData(map) {
        var _a, _b, _c;
        const localNavigator = globalThis.navigator;
        map.set("OS", ((_c = (_b = (_a = localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.userAgentData) === null || _a === void 0 ? void 0 : _a.platform) !== null && _b !== void 0 ? _b : localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.platform) !== null && _c !== void 0 ? _c : "unknown").replace(" ", ""));
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const SDK_VERSION = "1.0.0-beta.1";
    const DEFAULT_RETRY_POLICY_COUNT = 3;

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    function getUserAgentString(telemetryInfo) {
        const parts = [];
        for (const [key, value] of telemetryInfo) {
            const token = value ? `${key}/${value}` : key;
            parts.push(token);
        }
        return parts.join(" ");
    }
    /**
     * @internal
     */
    function getUserAgentHeaderName() {
        return getHeaderName();
    }
    /**
     * @internal
     */
    function getUserAgentValue(prefix) {
        const runtimeInfo = new Map();
        runtimeInfo.set("ts-http-runtime", SDK_VERSION);
        setPlatformSpecificData(runtimeInfo);
        const defaultAgent = getUserAgentString(runtimeInfo);
        const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
        return userAgentValue;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const UserAgentHeaderName = getUserAgentHeaderName();
    /**
     * The programmatic identifier of the userAgentPolicy.
     */
    const userAgentPolicyName = "userAgentPolicy";
    /**
     * A policy that sets the User-Agent header (or equivalent) to reflect
     * the library version.
     * @param options - Options to customize the user agent value.
     */
    function userAgentPolicy(options = {}) {
        const userAgentValue = getUserAgentValue(options.userAgentPrefix);
        return {
            name: userAgentPolicyName,
            async sendRequest(request, next) {
                if (!request.headers.has(UserAgentHeaderName)) {
                    request.headers.set(UserAgentHeaderName, userAgentValue);
                }
                return next(request);
            },
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /*
     * NOTE: When moving this file, please update "browser" section in package.json
     */
    /**
     * decompressResponsePolicy is not supported in the browser and attempting
     * to use it will raise an error.
     */
    function decompressResponsePolicy() {
        throw new Error("decompressResponsePolicy is not supported in browser environment");
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Returns a random integer value between a lower and upper bound,
     * inclusive of both bounds.
     * Note that this uses Math.random and isn't secure. If you need to use
     * this for any kind of security purpose, find a better source of random.
     * @param min - The smallest integer value allowed.
     * @param max - The largest integer value allowed.
     */
    function getRandomIntegerInclusive(min, max) {
        // Make sure inputs are integers.
        min = Math.ceil(min);
        max = Math.floor(max);
        // Pick a random offset from zero to the size of the range.
        // Since Math.random() can never return 1, we have to make the range one larger
        // in order to be inclusive of the maximum value after we take the floor.
        const offset = Math.floor(Math.random() * (max - min + 1));
        return offset + min;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * This error is thrown when an asynchronous operation has been aborted.
     * Check for this error by testing the `name` that the name property of the
     * error matches `"AbortError"`.
     *
     * @example
     * ```ts
     * const controller = new AbortController();
     * controller.abort();
     * try {
     *   doAsyncWork(controller.signal)
     * } catch (e) {
     *   if (e.name === 'AbortError') {
     *     // handle abort error here.
     *   }
     * }
     * ```
     */
    class AbortError extends Error {
        constructor(message) {
            super(message);
            this.name = "AbortError";
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const StandardAbortMessage = "The operation was aborted.";
    /**
     * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.
     * @param delayInMs - The number of milliseconds to be delayed.
     * @param value - The value to be resolved with after a timeout of t milliseconds.
     * @param options - The options for delay - currently abort options
     *                  - abortSignal - The abortSignal associated with containing operation.
     *                  - abortErrorMsg - The abort error message associated with containing operation.
     * @returns Resolved promise
     */
    function delay(delayInMs, value, options) {
        return new Promise((resolve, reject) => {
            let timer = undefined;
            let onAborted = undefined;
            const rejectOnAbort = () => {
                return reject(new AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));
            };
            const removeListeners = () => {
                if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
                    options.abortSignal.removeEventListener("abort", onAborted);
                }
            };
            onAborted = () => {
                if (timer) {
                    clearTimeout(timer);
                }
                removeListeners();
                return rejectOnAbort();
            };
            if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
                return rejectOnAbort();
            }
            timer = setTimeout(() => {
                removeListeners();
                resolve(value);
            }, delayInMs);
            if (options === null || options === void 0 ? void 0 : options.abortSignal) {
                options.abortSignal.addEventListener("abort", onAborted);
            }
        });
    }
    /**
     * @internal
     * @returns the parsed value or undefined if the parsed value is invalid.
     */
    function parseHeaderValueAsNumber(response, headerName) {
        const value = response.headers.get(headerName);
        if (!value)
            return;
        const valueAsNum = Number(value);
        if (Number.isNaN(valueAsNum))
            return;
        return valueAsNum;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * The header that comes back from services representing
     * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).
     */
    const RetryAfterHeader = "Retry-After";
    /**
     * The headers that come back from services representing
     * the amount of time (minimum) to wait to retry.
     *
     * "retry-after-ms", "x-ms-retry-after-ms" : milliseconds
     * "Retry-After" : seconds or timestamp
     */
    const AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
    /**
     * A response is a throttling retry response if it has a throttling status code (429 or 503),
     * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
     *
     * Returns the `retryAfterInMs` value if the response is a throttling retry response.
     * If not throttling retry response, returns `undefined`.
     *
     * @internal
     */
    function getRetryAfterInMs(response) {
        if (!(response && [429, 503].includes(response.status)))
            return undefined;
        try {
            // Headers: "retry-after-ms", "x-ms-retry-after-ms", "Retry-After"
            for (const header of AllRetryAfterHeaders) {
                const retryAfterValue = parseHeaderValueAsNumber(response, header);
                if (retryAfterValue === 0 || retryAfterValue) {
                    // "Retry-After" header ==> seconds
                    // "retry-after-ms", "x-ms-retry-after-ms" headers ==> milli-seconds
                    const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
                    return retryAfterValue * multiplyingFactor; // in milli-seconds
                }
            }
            // RetryAfterHeader ("Retry-After") has a special case where it might be formatted as a date instead of a number of seconds
            const retryAfterHeader = response.headers.get(RetryAfterHeader);
            if (!retryAfterHeader)
                return;
            const date = Date.parse(retryAfterHeader);
            const diff = date - Date.now();
            // negative diff would mean a date in the past, so retry asap with 0 milliseconds
            return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
        }
        catch (e) {
            return undefined;
        }
    }
    /**
     * A response is a retry response if it has a throttling status code (429 or 503),
     * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
     */
    function isThrottlingRetryResponse(response) {
        return Number.isFinite(getRetryAfterInMs(response));
    }
    function throttlingRetryStrategy() {
        return {
            name: "throttlingRetryStrategy",
            retry({ response }) {
                const retryAfterInMs = getRetryAfterInMs(response);
                if (!Number.isFinite(retryAfterInMs)) {
                    return { skipStrategy: true };
                }
                return {
                    retryAfterInMs,
                };
            },
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    // intervals are in milliseconds
    const DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
    const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
    /**
     * A retry strategy that retries with an exponentially increasing delay in these two cases:
     * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
     * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).
     */
    function exponentialRetryStrategy(options = {}) {
        var _a, _b;
        const retryInterval = (_a = options.retryDelayInMs) !== null && _a !== void 0 ? _a : DEFAULT_CLIENT_RETRY_INTERVAL;
        const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
        let retryAfterInMs = retryInterval;
        return {
            name: "exponentialRetryStrategy",
            retry({ retryCount, response, responseError }) {
                const matchedSystemError = isSystemError(responseError);
                const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
                const isExponential = isExponentialRetryResponse(response);
                const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
                const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
                if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
                    return { skipStrategy: true };
                }
                if (responseError && !matchedSystemError && !isExponential) {
                    return { errorToThrow: responseError };
                }
                // Exponentially increase the delay each time
                const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
                // Don't let the delay exceed the maximum
                const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
                // Allow the final value to have some "jitter" (within 50% of the delay size) so
                // that retries across multiple clients don't occur simultaneously.
                retryAfterInMs =
                    clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
                return { retryAfterInMs };
            },
        };
    }
    /**
     * A response is a retry response if it has status codes:
     * - 408, or
     * - Greater or equal than 500, except for 501 and 505.
     */
    function isExponentialRetryResponse(response) {
        return Boolean(response &&
            response.status !== undefined &&
            (response.status >= 500 || response.status === 408) &&
            response.status !== 501 &&
            response.status !== 505);
    }
    /**
     * Determines whether an error from a pipeline response was triggered in the network layer.
     */
    function isSystemError(err) {
        if (!err) {
            return false;
        }
        return (err.code === "ETIMEDOUT" ||
            err.code === "ESOCKETTIMEDOUT" ||
            err.code === "ECONNREFUSED" ||
            err.code === "ECONNRESET" ||
            err.code === "ENOENT" ||
            err.code === "ENOTFOUND");
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy");
    /**
     * The programmatic identifier of the retryPolicy.
     */
    const retryPolicyName = "retryPolicy";
    /**
     * retryPolicy is a generic policy to enable retrying requests when certain conditions are met
     */
    function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
        const logger = options.logger || retryPolicyLogger;
        return {
            name: retryPolicyName,
            async sendRequest(request, next) {
                var _a, _b;
                let response;
                let responseError;
                let retryCount = -1;
                // eslint-disable-next-line no-constant-condition
                retryRequest: while (true) {
                    retryCount += 1;
                    response = undefined;
                    responseError = undefined;
                    try {
                        logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
                        response = await next(request);
                        logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
                    }
                    catch (e) {
                        logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
                        // RestErrors are valid targets for the retry strategies.
                        // If none of the retry strategies can work with them, they will be thrown later in this policy.
                        // If the received error is not a RestError, it is immediately thrown.
                        responseError = e;
                        if (!e || responseError.name !== "RestError") {
                            throw e;
                        }
                        response = responseError.response;
                    }
                    if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
                        logger.error(`Retry ${retryCount}: Request aborted.`);
                        const abortError = new AbortError();
                        throw abortError;
                    }
                    if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {
                        logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
                        if (responseError) {
                            throw responseError;
                        }
                        else if (response) {
                            return response;
                        }
                        else {
                            throw new Error("Maximum retries reached with no response or error to throw");
                        }
                    }
                    logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
                    strategiesLoop: for (const strategy of strategies) {
                        const strategyLogger = strategy.logger || retryPolicyLogger;
                        strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                        const modifiers = strategy.retry({
                            retryCount,
                            response,
                            responseError,
                        });
                        if (modifiers.skipStrategy) {
                            strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                            continue strategiesLoop;
                        }
                        const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                        if (errorToThrow) {
                            strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                            throw errorToThrow;
                        }
                        if (retryAfterInMs || retryAfterInMs === 0) {
                            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                            await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });
                            continue retryRequest;
                        }
                        if (redirectTo) {
                            strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                            request.url = redirectTo;
                            continue retryRequest;
                        }
                    }
                    if (responseError) {
                        logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
                        throw responseError;
                    }
                    if (response) {
                        logger.info(`None of the retry strategies could work with the received response. Returning it.`);
                        return response;
                    }
                    // If all the retries skip and there's no response,
                    // we're still in the retry loop, so a new request will be sent
                    // until `maxRetries` is reached.
                }
            },
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Name of the {@link defaultRetryPolicy}
     */
    const defaultRetryPolicyName = "defaultRetryPolicy";
    /**
     * A policy that retries according to three strategies:
     * - When the server sends a 429 response with a Retry-After header.
     * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
     * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.
     */
    function defaultRetryPolicy(options = {}) {
        var _a;
        return {
            name: defaultRetryPolicyName,
            sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
                maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT,
            }).sendRequest,
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * The helper that transforms bytes with specific character encoding into string
     * @param bytes - the uint8array bytes
     * @param format - the format we use to encode the byte
     * @returns a string of the encoded string
     */
    /**
     * The helper that transforms string to specific character encoded bytes array.
     * @param value - the string to be converted
     * @param format - the format we use to decode the value
     * @returns a uint8array
     */
    function stringToUint8Array(value, format) {
        switch (format) {
            case "utf-8":
                return utf8StringToUint8Array(value);
            case "base64":
                return base64ToUint8Array(value);
            case "base64url":
                return base64UrlToUint8Array(value);
            case "hex":
                return hexStringToUint8Array(value);
        }
    }
    /**
     * Encodes a JavaScript string into a Uint8Array.
     * @internal
     */
    function utf8StringToUint8Array(value) {
        return new TextEncoder().encode(value);
    }
    /**
     * Encodes a Base64 string into a Uint8Array.
     * @internal
     */
    function base64ToUint8Array(value) {
        return new Uint8Array([...atob(value)].map((x) => x.charCodeAt(0)));
    }
    /**
     * Encodes a Base64Url string into a Uint8Array.
     * @internal
     */
    function base64UrlToUint8Array(value) {
        const base64String = value.replace(/-/g, "+").replace(/_/g, "/");
        return base64ToUint8Array(base64String);
    }
    const hexDigits = new Set("0123456789abcdefABCDEF");
    /**
     * Encodes a hex string into a Uint8Array
     * @internal
     */
    function hexStringToUint8Array(value) {
        // If value has odd length, the last character will be ignored, consistent with NodeJS Buffer behavior
        const bytes = new Uint8Array(value.length / 2);
        for (let i = 0; i < value.length / 2; ++i) {
            const highNibble = value[2 * i];
            const lowNibble = value[2 * i + 1];
            if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) {
                // Replicate Node Buffer behavior by exiting early when we encounter an invalid byte
                return bytes.slice(0, i);
            }
            bytes[i] = parseInt(`${highNibble}${lowNibble}`, 16);
        }
        return bytes;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    var _a$1, _b, _c, _d;
    /**
     * A constant that indicates whether the environment the code is running is a Web Worker.
     */
    typeof self === "object" &&
        typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" &&
        (((_a$1 = self.constructor) === null || _a$1 === void 0 ? void 0 : _a$1.name) === "DedicatedWorkerGlobalScope" ||
            ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "ServiceWorkerGlobalScope" ||
            ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "SharedWorkerGlobalScope");
    /**
     * A constant that indicates whether the environment the code is running is Bun.sh.
     */
    typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    /**
     * A constant that indicates whether the environment the code is running is Deno.
     */
    typeof Deno !== "undefined" &&
        typeof Deno.version !== "undefined" &&
        typeof Deno.version.deno !== "undefined";
    /**
     * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
     */
    const isNodeLike = typeof globalThis.process !== "undefined" &&
        Boolean(globalThis.process.version) &&
        Boolean((_d = globalThis.process.versions) === null || _d === void 0 ? void 0 : _d.node);

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    function normalizeName(name) {
        return name.toLowerCase();
    }
    function* headerIterator(map) {
        for (const entry of map.values()) {
            yield [entry.name, entry.value];
        }
    }
    class HttpHeadersImpl {
        constructor(rawHeaders) {
            this._headersMap = new Map();
            if (rawHeaders) {
                for (const headerName of Object.keys(rawHeaders)) {
                    this.set(headerName, rawHeaders[headerName]);
                }
            }
        }
        /**
         * Set a header in this collection with the provided name and value. The name is
         * case-insensitive.
         * @param name - The name of the header to set. This value is case-insensitive.
         * @param value - The value of the header to set.
         */
        set(name, value) {
            this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
        }
        /**
         * Get the header value for the provided header name, or undefined if no header exists in this
         * collection with the provided name.
         * @param name - The name of the header. This value is case-insensitive.
         */
        get(name) {
            var _a;
            return (_a = this._headersMap.get(normalizeName(name))) === null || _a === void 0 ? void 0 : _a.value;
        }
        /**
         * Get whether or not this header collection contains a header entry for the provided header name.
         * @param name - The name of the header to set. This value is case-insensitive.
         */
        has(name) {
            return this._headersMap.has(normalizeName(name));
        }
        /**
         * Remove the header with the provided headerName.
         * @param name - The name of the header to remove.
         */
        delete(name) {
            this._headersMap.delete(normalizeName(name));
        }
        /**
         * Get the JSON object representation of this HTTP header collection.
         */
        toJSON(options = {}) {
            const result = {};
            if (options.preserveCase) {
                for (const entry of this._headersMap.values()) {
                    result[entry.name] = entry.value;
                }
            }
            else {
                for (const [normalizedName, entry] of this._headersMap) {
                    result[normalizedName] = entry.value;
                }
            }
            return result;
        }
        /**
         * Get the string representation of this HTTP header collection.
         */
        toString() {
            return JSON.stringify(this.toJSON({ preserveCase: true }));
        }
        /**
         * Iterate over tuples of header [name, value] pairs.
         */
        [Symbol.iterator]() {
            return headerIterator(this._headersMap);
        }
    }
    /**
     * Creates an object that satisfies the `HttpHeaders` interface.
     * @param rawHeaders - A simple object representing initial headers
     */
    function createHttpHeaders(rawHeaders) {
        return new HttpHeadersImpl(rawHeaders);
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * The programmatic identifier of the formDataPolicy.
     */
    const formDataPolicyName = "formDataPolicy";
    function formDataToFormDataMap(formData) {
        var _a;
        const formDataMap = {};
        for (const [key, value] of formData.entries()) {
            (_a = formDataMap[key]) !== null && _a !== void 0 ? _a : (formDataMap[key] = []);
            formDataMap[key].push(value);
        }
        return formDataMap;
    }
    /**
     * A policy that encodes FormData on the request into the body.
     */
    function formDataPolicy() {
        return {
            name: formDataPolicyName,
            async sendRequest(request, next) {
                if (isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
                    request.formData = formDataToFormDataMap(request.body);
                    request.body = undefined;
                }
                if (request.formData) {
                    const contentType = request.headers.get("Content-Type");
                    if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
                        request.body = wwwFormUrlEncode(request.formData);
                    }
                    else {
                        await prepareFormData(request.formData, request);
                    }
                    request.formData = undefined;
                }
                return next(request);
            },
        };
    }
    function wwwFormUrlEncode(formData) {
        const urlSearchParams = new URLSearchParams();
        for (const [key, value] of Object.entries(formData)) {
            if (Array.isArray(value)) {
                for (const subValue of value) {
                    urlSearchParams.append(key, subValue.toString());
                }
            }
            else {
                urlSearchParams.append(key, value.toString());
            }
        }
        return urlSearchParams.toString();
    }
    async function prepareFormData(formData, request) {
        // validate content type (multipart/form-data)
        const contentType = request.headers.get("Content-Type");
        if (contentType && !contentType.startsWith("multipart/form-data")) {
            // content type is specified and is not multipart/form-data. Exit.
            return;
        }
        request.headers.set("Content-Type", contentType !== null && contentType !== void 0 ? contentType : "multipart/form-data");
        // set body to MultipartRequestBody using content from FormDataMap
        const parts = [];
        for (const [fieldName, values] of Object.entries(formData)) {
            for (const value of Array.isArray(values) ? values : [values]) {
                if (typeof value === "string") {
                    parts.push({
                        headers: createHttpHeaders({
                            "Content-Disposition": `form-data; name="${fieldName}"`,
                        }),
                        body: stringToUint8Array(value, "utf-8"),
                    });
                }
                else if (value === undefined || value === null || typeof value !== "object") {
                    throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
                }
                else {
                    // using || instead of ?? here since if value.name is empty we should create a file name
                    const fileName = value.name || "blob";
                    const headers = createHttpHeaders();
                    headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
                    // again, || is used since an empty value.type means the content type is unset
                    headers.set("Content-Type", value.type || "application/octet-stream");
                    parts.push({
                        headers,
                        body: value,
                    });
                }
            }
        }
        request.multipartBody = { parts };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /*
     * NOTE: When moving this file, please update "browser" section in package.json
     */
    const errorMessage = "proxyPolicy is not supported in browser environment";
    /**
     * proxyPolicy is not supported in the browser and attempting
     * to use it will raise an error.
     */
    function proxyPolicy() {
        throw new Error(errorMessage);
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Name of the TLS Policy
     */
    const tlsPolicyName = "tlsPolicy";
    /**
     * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.
     */
    function tlsPolicy(tlsSettings) {
        return {
            name: tlsPolicyName,
            sendRequest: async (req, next) => {
                // Users may define a request tlsSettings, honor those over the client level one
                if (!req.tlsSettings) {
                    req.tlsSettings = tlsSettings;
                }
                return next(req);
            },
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /** @internal */
    const knownContextKeys = {
        span: Symbol.for("@typespec/ts-http-runtime span"),
        namespace: Symbol.for("@typespec/ts-http-runtime namespace"),
    };
    /**
     * Creates a new {@link TracingContext} with the given options.
     * @param options - A set of known keys that may be set on the context.
     * @returns A new {@link TracingContext} with the given options.
     *
     * @internal
     */
    function createTracingContext(options = {}) {
        let context = new TracingContextImpl(options.parentContext);
        if (options.span) {
            context = context.setValue(knownContextKeys.span, options.span);
        }
        if (options.namespace) {
            context = context.setValue(knownContextKeys.namespace, options.namespace);
        }
        return context;
    }
    /** @internal */
    class TracingContextImpl {
        constructor(initialContext) {
            this._contextMap =
                initialContext instanceof TracingContextImpl
                    ? new Map(initialContext._contextMap)
                    : new Map();
        }
        setValue(key, value) {
            const newContext = new TracingContextImpl(this);
            newContext._contextMap.set(key, value);
            return newContext;
        }
        getValue(key) {
            return this._contextMap.get(key);
        }
        deleteValue(key) {
            const newContext = new TracingContextImpl(this);
            newContext._contextMap.delete(key);
            return newContext;
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    function createDefaultTracingSpan() {
        return {
            end: () => {
                // noop
            },
            isRecording: () => false,
            recordException: () => {
                // noop
            },
            setAttribute: () => {
                // noop
            },
            setStatus: () => {
                // noop
            },
        };
    }
    function createDefaultInstrumenter() {
        return {
            createRequestHeaders: () => {
                return {};
            },
            parseTraceparentHeader: () => {
                return undefined;
            },
            startSpan: (_name, spanOptions) => {
                return {
                    span: createDefaultTracingSpan(),
                    tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext }),
                };
            },
            withContext(_context, callback, ...callbackArgs) {
                return callback(...callbackArgs);
            },
        };
    }
    /** @internal */
    let instrumenterImplementation;
    /**
     * Gets the currently set instrumenter, a No-Op instrumenter by default.
     *
     * @returns The currently set instrumenter
     */
    function getInstrumenter() {
        if (!instrumenterImplementation) {
            instrumenterImplementation = createDefaultInstrumenter();
        }
        return instrumenterImplementation;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Creates a new tracing client.
     *
     * @param options - Options used to configure the tracing client.
     * @returns - An instance of {@link TracingClient}.
     */
    function createTracingClient(options) {
        const { namespace, packageName, packageVersion } = options;
        function startSpan(name, operationOptions, spanOptions) {
            var _a;
            const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName: packageName, packageVersion: packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext }));
            let tracingContext = startSpanResult.tracingContext;
            const span = startSpanResult.span;
            if (!tracingContext.getValue(knownContextKeys.namespace)) {
                tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
            }
            span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
            const updatedOptions = Object.assign({}, operationOptions, {
                tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext }),
            });
            return {
                span,
                updatedOptions,
            };
        }
        async function withSpan(name, operationOptions, callback, spanOptions) {
            const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
            try {
                const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
                span.setStatus({ status: "success" });
                return result;
            }
            catch (err) {
                span.setStatus({ status: "error", error: err });
                throw err;
            }
            finally {
                span.end();
            }
        }
        function withContext(context, callback, ...callbackArgs) {
            return getInstrumenter().withContext(context, callback, ...callbackArgs);
        }
        /**
         * Parses a traceparent header value into a span identifier.
         *
         * @param traceparentHeader - The traceparent header to parse.
         * @returns An implementation-specific identifier for the span.
         */
        function parseTraceparentHeader(traceparentHeader) {
            return getInstrumenter().parseTraceparentHeader(traceparentHeader);
        }
        /**
         * Creates a set of request headers to propagate tracing information to a backend.
         *
         * @param tracingContext - The context containing the span to serialize.
         * @returns The set of headers to add to a request.
         */
        function createRequestHeaders(tracingContext) {
            return getInstrumenter().createRequestHeaders(tracingContext);
        }
        return {
            startSpan,
            withSpan,
            withContext,
            parseTraceparentHeader,
            createRequestHeaders,
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Typeguard for an error object shape (has name and message)
     * @param e - Something caught by a catch clause.
     */
    function isError(e) {
        if (isObject(e)) {
            const hasName = typeof e.name === "string";
            const hasMessage = typeof e.message === "string";
            return hasName && hasMessage;
        }
        return false;
    }
    /**
     * Given what is thought to be an error object, return the message if possible.
     * If the message is missing, returns a stringified version of the input.
     * @param e - Something thrown from a try block
     * @returns The error message or a string of the input
     */
    function getErrorMessage(e) {
        if (isError(e)) {
            return e.message;
        }
        else {
            let stringified;
            try {
                if (typeof e === "object" && e) {
                    stringified = JSON.stringify(e);
                }
                else {
                    stringified = String(e);
                }
            }
            catch (err) {
                stringified = "[unable to stringify input]";
            }
            return `Unknown error ${stringified}`;
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const custom = {};

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const errorSanitizer = new Sanitizer();
    /**
     * A custom error type for failed pipeline requests.
     */
    class RestError extends Error {
        constructor(message, options = {}) {
            super(message);
            this.name = "RestError";
            this.code = options.code;
            this.statusCode = options.statusCode;
            this.request = options.request;
            this.response = options.response;
            Object.setPrototypeOf(this, RestError.prototype);
        }
        /**
         * Logging method for util.inspect in Node
         */
        [custom]() {
            return `RestError: ${this.message} \n ${errorSanitizer.sanitize(this)}`;
        }
    }
    /**
     * Something went wrong when making the request.
     * This means the actual request failed for some reason,
     * such as a DNS issue or the connection being lost.
     */
    RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    /**
     * This means that parsing the response from the server failed.
     * It may have been malformed.
     */
    RestError.PARSE_ERROR = "PARSE_ERROR";
    /**
     * Typeguard for RestError
     * @param e - Something caught by a catch clause.
     */
    function isRestError(e) {
        if (e instanceof RestError) {
            return true;
        }
        return isError(e) && e.name === "RestError";
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * The programmatic identifier of the tracingPolicy.
     */
    const tracingPolicyName = "tracingPolicy";
    /**
     * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
     * that has SpanOptions with a parent.
     * Requests made without a parent Span will not be recorded.
     * @param options - Options to configure the telemetry logged by the tracing policy.
     */
    function tracingPolicy(options = {}) {
        const userAgent = getUserAgentValue(options.userAgentPrefix);
        const sanitizer = new Sanitizer({
            additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,
        });
        const tracingClient = tryCreateTracingClient();
        return {
            name: tracingPolicyName,
            async sendRequest(request, next) {
                var _a, _b;
                if (!tracingClient || !((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) {
                    return next(request);
                }
                const spanAttributes = {
                    "http.url": sanitizer.sanitizeUrl(request.url),
                    "http.method": request.method,
                    "http.user_agent": userAgent,
                    requestId: request.requestId,
                };
                if (userAgent) {
                    spanAttributes["http.user_agent"] = userAgent;
                }
                const { span, tracingContext } = (_b = tryCreateSpan(tracingClient, request, spanAttributes)) !== null && _b !== void 0 ? _b : {};
                if (!span || !tracingContext) {
                    return next(request);
                }
                try {
                    const response = await tracingClient.withContext(tracingContext, next, request);
                    tryProcessResponse(span, response);
                    return response;
                }
                catch (err) {
                    tryProcessError(span, err);
                    throw err;
                }
            },
        };
    }
    function tryCreateTracingClient() {
        try {
            return createTracingClient({
                namespace: "",
                packageName: "@typespec/ts-http-runtime",
                packageVersion: SDK_VERSION,
            });
        }
        catch (e) {
            logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
            return undefined;
        }
    }
    function tryCreateSpan(tracingClient, request, spanAttributes) {
        try {
            // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
            const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
                spanKind: "client",
                spanAttributes,
            });
            // If the span is not recording, don't do any more work.
            if (!span.isRecording()) {
                span.end();
                return undefined;
            }
            // set headers
            const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
            for (const [key, value] of Object.entries(headers)) {
                request.headers.set(key, value);
            }
            return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
        }
        catch (e) {
            logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
            return undefined;
        }
    }
    function tryProcessError(span, error) {
        try {
            span.setStatus({
                status: "error",
                error: isError(error) ? error : undefined,
            });
            if (isRestError(error) && error.statusCode) {
                span.setAttribute("http.status_code", error.statusCode);
            }
            span.end();
        }
        catch (e) {
            logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
        }
    }
    function tryProcessResponse(span, response) {
        try {
            span.setAttribute("http.status_code", response.status);
            const serviceRequestId = response.headers.get("x-ms-request-id");
            if (serviceRequestId) {
                span.setAttribute("serviceRequestId", serviceRequestId);
            }
            span.setStatus({
                status: "success",
            });
            span.end();
        }
        catch (e) {
            logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Helper TypeGuard that checks if something is defined or not.
     * @param thing - Anything
     */
    function isDefined(thing) {
        return typeof thing !== "undefined" && thing !== null;
    }
    /**
     * Helper TypeGuard that checks if the input is an object with the specified properties.
     * @param thing - Anything.
     * @param properties - The name of the properties that should appear in the object.
     */
    function isObjectWithProperties(thing, properties) {
        if (!isDefined(thing) || typeof thing !== "object") {
            return false;
        }
        for (const property of properties) {
            if (!objectHasProperty(thing, property)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Helper TypeGuard that checks if the input is an object with the specified property.
     * @param thing - Any object.
     * @param property - The name of the property that should appear in the object.
     */
    function objectHasProperty(thing, property) {
        return (isDefined(thing) && typeof thing === "object" && property in thing);
    }
    function isNodeReadableStream(x) {
        return Boolean(x && typeof x["pipe"] === "function");
    }
    function isWebReadableStream(x) {
        return Boolean(x &&
            typeof x.getReader === "function" &&
            typeof x.tee === "function");
    }
    function isBinaryBody(body) {
        return (body !== undefined &&
            (body instanceof Uint8Array ||
                isReadableStream(body) ||
                typeof body === "function" ||
                body instanceof Blob));
    }
    function isReadableStream(x) {
        return isNodeReadableStream(x) || isWebReadableStream(x);
    }
    function isBlob$1(x) {
        return typeof x.stream === "function";
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /*
     * NOTE: When moving this file, please update "react-native" section in package.json.
     */
    /**
     * Generated Universally Unique Identifier
     *
     * @returns RFC4122 v4 UUID.
     */
    function generateUUID() {
        let uuid = "";
        for (let i = 0; i < 32; i++) {
            // Generate a random number between 0 and 15
            const randomNumber = Math.floor(Math.random() * 16);
            // Set the UUID version to 4 in the 13th position
            if (i === 12) {
                uuid += "4";
            }
            else if (i === 16) {
                // Set the UUID variant to "10" in the 17th position
                uuid += (randomNumber & 0x3) | 0x8;
            }
            else {
                // Add a random hexadecimal digit to the UUID string
                uuid += randomNumber.toString(16);
            }
            // Add hyphens to the UUID string at the appropriate positions
            if (i === 7 || i === 11 || i === 15 || i === 19) {
                uuid += "-";
            }
        }
        return uuid;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    var _a;
    // NOTE: This could be undefined if not used in a secure context
    const uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function"
        ? globalThis.crypto.randomUUID.bind(globalThis.crypto)
        : generateUUID;
    /**
     * Generated Universally Unique Identifier
     *
     * @returns RFC4122 v4 UUID.
     */
    function randomUUID() {
        return uuidFunction();
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Private symbol used as key on objects created using createFile containing the
     * original source of the file object.
     *
     * This is used in Node to access the original Node stream without using Blob#stream, which
     * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and
     * Readable#to/fromWeb in Node versions we support:
     * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)
     * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)
     *
     * Once these versions are no longer supported, we may be able to stop doing this.
     *
     * @internal
     */
    const rawContent = Symbol("rawContent");
    function hasRawContent(x) {
        return typeof x[rawContent] === "function";
    }
    /**
     * Extract the raw content from a given blob-like object. If the input was created using createFile
     * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.
     * For true instances of Blob and File, returns the blob's content as a Web ReadableStream<Uint8Array>.
     *
     * @internal
     */
    function getRawContent(blob) {
        if (hasRawContent(blob)) {
            return blob[rawContent]();
        }
        else {
            return blob.stream();
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Drain the content of the given ReadableStream into a Blob.
     * The blob's content may end up in memory or on disk dependent on size.
     */
    function drain(stream) {
        return new Response(stream).blob();
    }
    async function toBlobPart(source) {
        if (source instanceof Blob || source instanceof Uint8Array) {
            return source;
        }
        if (isWebReadableStream(source)) {
            return drain(source);
        }
        // If it's not a true Blob, and it's not a Uint8Array, we can assume the source
        // is a fake File created by createFileFromStream and we can get the original stream
        // using getRawContent.
        const rawContent = getRawContent(source);
        // Shouldn't happen but guard for it anyway
        if (isNodeReadableStream(rawContent)) {
            throw new Error("Encountered unexpected type. In the browser, `concat` supports Web ReadableStream, Blob, Uint8Array, and files created using `createFile` only.");
        }
        return toBlobPart(rawContent);
    }
    /**
     * Utility function that concatenates a set of binary inputs into one combined output.
     *
     * @param sources - array of sources for the concatenation
     * @returns - in Node, a (() =\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.
     *           In browser, returns a `Blob` representing all the concatenated inputs.
     *
     * @internal
     */
    async function concat(sources) {
        const parts = [];
        for (const source of sources) {
            parts.push(await toBlobPart(typeof source === "function" ? source() : source));
        }
        return new Blob(parts);
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    function generateBoundary() {
        return `----AzSDKFormBoundary${randomUUID()}`;
    }
    function encodeHeaders(headers) {
        let result = "";
        for (const [key, value] of headers) {
            result += `${key}: ${value}\r\n`;
        }
        return result;
    }
    function getLength(source) {
        if (source instanceof Uint8Array) {
            return source.byteLength;
        }
        else if (isBlob$1(source)) {
            // if was created using createFile then -1 means we have an unknown size
            return source.size === -1 ? undefined : source.size;
        }
        else {
            return undefined;
        }
    }
    function getTotalLength(sources) {
        let total = 0;
        for (const source of sources) {
            const partLength = getLength(source);
            if (partLength === undefined) {
                return undefined;
            }
            else {
                total += partLength;
            }
        }
        return total;
    }
    async function buildRequestBody$1(request, parts, boundary) {
        const sources = [
            stringToUint8Array(`--${boundary}`, "utf-8"),
            ...parts.flatMap((part) => [
                stringToUint8Array("\r\n", "utf-8"),
                stringToUint8Array(encodeHeaders(part.headers), "utf-8"),
                stringToUint8Array("\r\n", "utf-8"),
                part.body,
                stringToUint8Array(`\r\n--${boundary}`, "utf-8"),
            ]),
            stringToUint8Array("--\r\n\r\n", "utf-8"),
        ];
        const contentLength = getTotalLength(sources);
        if (contentLength) {
            request.headers.set("Content-Length", contentLength);
        }
        request.body = await concat(sources);
    }
    /**
     * Name of multipart policy
     */
    const multipartPolicyName = "multipartPolicy";
    const maxBoundaryLength = 70;
    const validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
    function assertValidBoundary(boundary) {
        if (boundary.length > maxBoundaryLength) {
            throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
        }
        if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
            throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
        }
    }
    /**
     * Pipeline policy for multipart requests
     */
    function multipartPolicy() {
        return {
            name: multipartPolicyName,
            async sendRequest(request, next) {
                var _a;
                if (!request.multipartBody) {
                    return next(request);
                }
                if (request.body) {
                    throw new Error("multipartBody and regular body cannot be set at the same time");
                }
                let boundary = request.multipartBody.boundary;
                const contentTypeHeader = (_a = request.headers.get("Content-Type")) !== null && _a !== void 0 ? _a : "multipart/mixed";
                const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
                if (!parsedHeader) {
                    throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
                }
                const [, contentType, parsedBoundary] = parsedHeader;
                if (parsedBoundary && boundary && parsedBoundary !== boundary) {
                    throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
                }
                boundary !== null && boundary !== void 0 ? boundary : (boundary = parsedBoundary);
                if (boundary) {
                    assertValidBoundary(boundary);
                }
                else {
                    boundary = generateBoundary();
                }
                request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
                await buildRequestBody$1(request, request.multipartBody.parts, boundary);
                request.multipartBody = undefined;
                return next(request);
            },
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Create a new pipeline with a default set of customizable policies.
     * @param options - Options to configure a custom pipeline.
     */
    function createPipelineFromOptions(options) {
        const pipeline = createEmptyPipeline();
        if (isNodeLike) {
            if (options.tlsOptions) {
                pipeline.addPolicy(tlsPolicy(options.tlsOptions));
            }
            pipeline.addPolicy(proxyPolicy(options.proxyOptions));
            pipeline.addPolicy(decompressResponsePolicy());
        }
        pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });
        pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
        // The multipart policy is added after policies with no phase, so that
        // policies can be added between it and formDataPolicy to modify
        // properties (e.g., making the boundary constant in recorded tests).
        pipeline.addPolicy(multipartPolicy(), { afterPhase: "Deserialize" });
        pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
        pipeline.addPolicy(tracingPolicy(Object.assign(Object.assign({}, options.userAgentOptions), options.loggingOptions)), {
            afterPhase: "Retry",
        });
        if (isNodeLike) {
            // Both XHR and Fetch expect to handle redirects automatically,
            // so only include this policy when we're in Node.
            pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
        }
        pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
        return pipeline;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Checks if the body is a Blob or Blob-like
     */
    function isBlob(body) {
        // File objects count as a type of Blob, so we want to use instanceof explicitly
        return (typeof Blob === "function" || typeof Blob === "object") && body instanceof Blob;
    }
    /**
     * A HttpClient implementation that uses window.fetch to send HTTP requests.
     * @internal
     */
    class FetchHttpClient {
        /**
         * Makes a request over an underlying transport layer and returns the response.
         * @param request - The request to be made.
         */
        async sendRequest(request) {
            const url = new URL(request.url);
            const isInsecure = url.protocol !== "https:";
            if (isInsecure && !request.allowInsecureConnection) {
                throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
            }
            if (request.proxySettings) {
                throw new Error("HTTP proxy is not supported in browser environment");
            }
            try {
                return await makeRequest(request);
            }
            catch (e) {
                throw getError(e, request);
            }
        }
    }
    /**
     * Sends a request
     */
    async function makeRequest(request) {
        const { abortController, abortControllerCleanup } = setupAbortSignal(request);
        try {
            const headers = buildFetchHeaders(request.headers);
            const { streaming, body: requestBody } = buildRequestBody(request);
            const requestInit = Object.assign(Object.assign({ body: requestBody, method: request.method, headers: headers, signal: abortController.signal }, ("credentials" in Request.prototype
                ? { credentials: request.withCredentials ? "include" : "same-origin" }
                : {})), ("cache" in Request.prototype ? { cache: "no-store" } : {}));
            // According to https://fetch.spec.whatwg.org/#fetch-method,
            // init.duplex must be set when body is a ReadableStream object.
            // currently "half" is the only valid value.
            if (streaming) {
                requestInit.duplex = "half";
            }
            /**
             * Developers of the future:
             * Do not set redirect: "manual" as part
             * of request options.
             * It will not work as you expect.
             */
            const response = await fetch(request.url, requestInit);
            // If we're uploading a blob, we need to fire the progress event manually
            if (isBlob(request.body) && request.onUploadProgress) {
                request.onUploadProgress({ loadedBytes: request.body.size });
            }
            return buildPipelineResponse(response, request, abortControllerCleanup);
        }
        catch (e) {
            abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
            throw e;
        }
    }
    /**
     * Creates a pipeline response from a Fetch response;
     */
    async function buildPipelineResponse(httpResponse, request, abortControllerCleanup) {
        var _a, _b;
        const headers = buildPipelineHeaders(httpResponse);
        const response = {
            request,
            headers,
            status: httpResponse.status,
        };
        const bodyStream = isReadableStream(httpResponse.body)
            ? buildBodyStream(httpResponse.body, {
                onProgress: request.onDownloadProgress,
                onEnd: abortControllerCleanup,
            })
            : httpResponse.body;
        if (
        // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
        ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) ||
            ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {
            if (request.enableBrowserStreams) {
                response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;
            }
            else {
                const responseStream = new Response(bodyStream);
                response.blobBody = responseStream.blob();
                abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
            }
        }
        else {
            const responseStream = new Response(bodyStream);
            response.bodyAsText = await responseStream.text();
            abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
        }
        return response;
    }
    function setupAbortSignal(request) {
        const abortController = new AbortController();
        // Cleanup function
        let abortControllerCleanup;
        /**
         * Attach an abort listener to the request
         */
        let abortListener;
        if (request.abortSignal) {
            if (request.abortSignal.aborted) {
                throw new AbortError("The operation was aborted.");
            }
            abortListener = (event) => {
                if (event.type === "abort") {
                    abortController.abort();
                }
            };
            request.abortSignal.addEventListener("abort", abortListener);
            abortControllerCleanup = () => {
                var _a;
                if (abortListener) {
                    (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", abortListener);
                }
            };
        }
        // If a timeout was passed, call the abort signal once the time elapses
        if (request.timeout > 0) {
            setTimeout(() => {
                abortController.abort();
            }, request.timeout);
        }
        return { abortController, abortControllerCleanup };
    }
    /**
     * Gets the specific error
     */
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    function getError(e, request) {
        var _a;
        if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
            return e;
        }
        else {
            return new RestError(`Error sending request: ${e.message}`, {
                code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,
                request,
            });
        }
    }
    /**
     * Converts PipelineRequest headers to Fetch headers
     */
    function buildFetchHeaders(pipelineHeaders) {
        const headers = new Headers();
        for (const [name, value] of pipelineHeaders) {
            headers.append(name, value);
        }
        return headers;
    }
    function buildPipelineHeaders(httpResponse) {
        const responseHeaders = createHttpHeaders();
        for (const [name, value] of httpResponse.headers) {
            responseHeaders.set(name, value);
        }
        return responseHeaders;
    }
    function buildRequestBody(request) {
        const body = typeof request.body === "function" ? request.body() : request.body;
        if (isNodeReadableStream(body)) {
            throw new Error("Node streams are not supported in browser environment.");
        }
        return isReadableStream(body)
            ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) }
            : { streaming: false, body };
    }
    /**
     * Reads the request/response original stream and stream it through a new
     * ReadableStream, this is done to be able to report progress in a way that
     * all modern browsers support. TransformStreams would be an alternative,
     * however they are not yet supported by all browsers i.e Firefox
     */
    function buildBodyStream(readableStream, options = {}) {
        let loadedBytes = 0;
        const { onProgress, onEnd } = options;
        // If the current browser supports pipeThrough we use a TransformStream
        // to report progress
        if (isTransformStreamSupported(readableStream)) {
            return readableStream.pipeThrough(new TransformStream({
                transform(chunk, controller) {
                    if (chunk === null) {
                        controller.terminate();
                        return;
                    }
                    controller.enqueue(chunk);
                    loadedBytes += chunk.length;
                    if (onProgress) {
                        onProgress({ loadedBytes });
                    }
                },
                flush() {
                    onEnd === null || onEnd === void 0 ? void 0 : onEnd();
                },
            }));
        }
        else {
            // If we can't use transform streams, wrap the original stream in a new readable stream
            // and use pull to enqueue each chunk and report progress.
            const reader = readableStream.getReader();
            return new ReadableStream({
                async pull(controller) {
                    var _a;
                    const { done, value } = await reader.read();
                    // When no more data needs to be consumed, break the reading
                    if (done || !value) {
                        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
                        // Close the stream
                        controller.close();
                        reader.releaseLock();
                        return;
                    }
                    loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;
                    // Enqueue the next data chunk into our target stream
                    controller.enqueue(value);
                    if (onProgress) {
                        onProgress({ loadedBytes });
                    }
                },
                cancel(reason) {
                    onEnd === null || onEnd === void 0 ? void 0 : onEnd();
                    return reader.cancel(reason);
                },
            });
        }
    }
    /**
     * Create a new HttpClient instance for the browser environment.
     * @internal
     */
    function createFetchHttpClient() {
        return new FetchHttpClient();
    }
    function isTransformStreamSupported(readableStream) {
        return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Create the correct HttpClient for the current environment.
     */
    function createDefaultHttpClient() {
        return createFetchHttpClient();
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    class PipelineRequestImpl {
        constructor(options) {
            var _a, _b, _c, _d, _e, _f, _g;
            this.url = options.url;
            this.body = options.body;
            this.headers = (_a = options.headers) !== null && _a !== void 0 ? _a : createHttpHeaders();
            this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET";
            this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;
            this.multipartBody = options.multipartBody;
            this.formData = options.formData;
            this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;
            this.proxySettings = options.proxySettings;
            this.streamResponseStatusCodes = options.streamResponseStatusCodes;
            this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
            this.abortSignal = options.abortSignal;
            this.tracingOptions = options.tracingOptions;
            this.onUploadProgress = options.onUploadProgress;
            this.onDownloadProgress = options.onDownloadProgress;
            this.requestId = options.requestId || randomUUID();
            this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
            this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
        }
    }
    /**
     * Creates a new pipeline request with the given options.
     * This method is to allow for the easy setting of default values and not required.
     * @param options - The options to create the request with.
     */
    function createPipelineRequest(options) {
        return new PipelineRequestImpl(options);
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    // Default options for the cycler if none are provided
    const DEFAULT_CYCLER_OPTIONS = {
        forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires
        retryIntervalInMs: 3000, // Allow refresh attempts every 3s
        refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry
    };
    /**
     * Converts an an unreliable access token getter (which may resolve with null)
     * into an AccessTokenGetter by retrying the unreliable getter in a regular
     * interval.
     *
     * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
     * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
     * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
     * @returns - A promise that, if it resolves, will resolve with an access token.
     */
    async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
        // This wrapper handles exceptions gracefully as long as we haven't exceeded
        // the timeout.
        async function tryGetAccessToken() {
            if (Date.now() < refreshTimeout) {
                try {
                    return await getAccessToken();
                }
                catch (_a) {
                    return null;
                }
            }
            else {
                const finalToken = await getAccessToken();
                // Timeout is up, so throw if it's still null
                if (finalToken === null) {
                    throw new Error("Failed to refresh access token.");
                }
                return finalToken;
            }
        }
        let token = await tryGetAccessToken();
        while (token === null) {
            await delay(retryIntervalInMs);
            token = await tryGetAccessToken();
        }
        return token;
    }
    /**
     * Creates a token cycler from a credential, scopes, and optional settings.
     *
     * A token cycler represents a way to reliably retrieve a valid access token
     * from a TokenCredential. It will handle initializing the token, refreshing it
     * when it nears expiration, and synchronizes refresh attempts to avoid
     * concurrency hazards.
     *
     * @param credential - the underlying TokenCredential that provides the access
     * token
     * @param tokenCyclerOptions - optionally override default settings for the cycler
     *
     * @returns - a function that reliably produces a valid access token
     */
    function createTokenCycler(credential, tokenCyclerOptions) {
        let refreshWorker = null;
        let token = null;
        let tenantId;
        const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
        /**
         * This little holder defines several predicates that we use to construct
         * the rules of refreshing the token.
         */
        const cycler = {
            /**
             * Produces true if a refresh job is currently in progress.
             */
            get isRefreshing() {
                return refreshWorker !== null;
            },
            /**
             * Produces true if the cycler SHOULD refresh (we are within the refresh
             * window and not already refreshing)
             */
            get shouldRefresh() {
                var _a;
                return (!cycler.isRefreshing &&
                    ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now());
            },
            /**
             * Produces true if the cycler MUST refresh (null or nearly-expired
             * token).
             */
            get mustRefresh() {
                return (token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now());
            },
        };
        /**
         * Starts a refresh job or returns the existing job if one is already
         * running.
         */
        function refresh(scopes, getTokenOptions) {
            var _a;
            if (!cycler.isRefreshing) {
                // We bind `scopes` here to avoid passing it around a lot
                const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
                // Take advantage of promise chaining to insert an assignment to `token`
                // before the refresh can be considered done.
                refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, 
                // If we don't have a token, then we should timeout immediately
                (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now())
                    .then((_token) => {
                    refreshWorker = null;
                    token = _token;
                    tenantId = getTokenOptions.tenantId;
                    return token;
                })
                    .catch((reason) => {
                    // We also should reset the refresher if we enter a failed state.  All
                    // existing awaiters will throw, but subsequent requests will start a
                    // new retry chain.
                    refreshWorker = null;
                    token = null;
                    tenantId = undefined;
                    throw reason;
                });
            }
            return refreshWorker;
        }
        return async (scopes, tokenOptions) => {
            //
            // Simple rules:
            // - If we MUST refresh, then return the refresh task, blocking
            //   the pipeline until a token is available.
            // - If we SHOULD refresh, then run refresh but don't return it
            //   (we can still use the cached token).
            // - Return the token, since it's fine if we didn't return in
            //   step 1.
            //
            const hasClaimChallenge = Boolean(tokenOptions.claims);
            const tenantIdChanged = tenantId !== tokenOptions.tenantId;
            if (hasClaimChallenge) {
                // If we've received a claim, we know the existing token isn't valid
                // We want to clear it so that that refresh worker won't use the old expiration time as a timeout
                token = null;
            }
            // If the tenantId passed in token options is different to the one we have
            // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to
            // refresh the token with the new tenantId or token.
            const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
            if (mustRefresh) {
                return refresh(scopes, tokenOptions);
            }
            if (cycler.shouldRefresh) {
                refresh(scopes, tokenOptions);
            }
            return token;
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * The programmatic identifier of the bearerTokenAuthenticationPolicy.
     */
    const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
    /**
     * Default authorize request handler
     */
    async function defaultAuthorizeRequest(options) {
        const { scopes, getAccessToken, request } = options;
        const getTokenOptions = {
            abortSignal: request.abortSignal,
            tracingOptions: request.tracingOptions,
        };
        const accessToken = await getAccessToken(scopes, getTokenOptions);
        if (accessToken) {
            options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
        }
    }
    /**
     * We will retrieve the challenge only if the response status code was 401,
     * and if the response contained the header "WWW-Authenticate" with a non-empty value.
     */
    function getChallenge(response) {
        const challenge = response.headers.get("WWW-Authenticate");
        if (response.status === 401 && challenge) {
            return challenge;
        }
        return;
    }
    /**
     * A policy that can request a token from a TokenCredential implementation and
     * then apply it to the Authorization header of a request as a Bearer token.
     */
    function bearerTokenAuthenticationPolicy(options) {
        var _a;
        const { credential, scopes, challengeCallbacks } = options;
        const logger$1 = options.logger || logger;
        const callbacks = Object.assign({ authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
        // This function encapsulates the entire process of reliably retrieving the token
        // The options are left out of the public API until there's demand to configure this.
        // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`
        // in order to pass through the `options` object.
        const getAccessToken = credential
            ? createTokenCycler(credential /* , options */)
            : () => Promise.resolve(null);
        return {
            name: bearerTokenAuthenticationPolicyName,
            /**
             * If there's no challenge parameter:
             * - It will try to retrieve the token using the cache, or the credential's getToken.
             * - Then it will try the next policy with or without the retrieved token.
             *
             * It uses the challenge parameters to:
             * - Skip a first attempt to get the token from the credential if there's no cached token,
             *   since it expects the token to be retrievable only after the challenge.
             * - Prepare the outgoing request if the `prepareRequest` method has been provided.
             * - Send an initial request to receive the challenge if it fails.
             * - Process a challenge if the response contains it.
             * - Retrieve a token with the challenge information, then re-send the request.
             */
            async sendRequest(request, next) {
                if (!request.url.toLowerCase().startsWith("https://")) {
                    throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
                }
                await callbacks.authorizeRequest({
                    scopes: Array.isArray(scopes) ? scopes : [scopes],
                    request,
                    getAccessToken,
                    logger: logger$1,
                });
                let response;
                let error;
                try {
                    response = await next(request);
                }
                catch (err) {
                    error = err;
                    response = err.response;
                }
                if (callbacks.authorizeRequestOnChallenge &&
                    (response === null || response === void 0 ? void 0 : response.status) === 401 &&
                    getChallenge(response)) {
                    // processes challenge
                    const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
                        scopes: Array.isArray(scopes) ? scopes : [scopes],
                        request,
                        response,
                        getAccessToken,
                        logger: logger$1,
                    });
                    if (shouldSendRequest) {
                        return next(request);
                    }
                }
                if (error) {
                    throw error;
                }
                else {
                    return response;
                }
            },
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Tests an object to determine whether it implements KeyCredential.
     *
     * @param credential - The assumed KeyCredential to be tested.
     */
    function isKeyCredential(credential) {
        return isObjectWithProperties(credential, ["key"]) && typeof credential.key === "string";
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Tests an object to determine whether it implements TokenCredential.
     *
     * @param credential - The assumed TokenCredential to be tested.
     */
    function isTokenCredential$1(credential) {
        // Check for an object with a 'getToken' function and possibly with
        // a 'signRequest' function.  We do this check to make sure that
        // a ServiceClientCredentials implementor (like TokenClientCredentials
        // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
        // it doesn't actually implement TokenCredential also.
        const castCredential = credential;
        return (castCredential &&
            typeof castCredential.getToken === "function" &&
            (castCredential.signRequest === undefined || castCredential.getToken.length > 0));
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const apiVersionPolicyName = "ApiVersionPolicy";
    /**
     * Creates a policy that sets the apiVersion as a query parameter on every request
     * @param options - Client options
     * @returns Pipeline policy that sets the apiVersion as a query parameter on every request
     */
    function apiVersionPolicy(options) {
        return {
            name: apiVersionPolicyName,
            sendRequest: (req, next) => {
                // Use the apiVesion defined in request url directly
                // Append one if there is no apiVesion and we have one at client options
                const url = new URL(req.url);
                if (!url.searchParams.get("api-version") && options.apiVersion) {
                    req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
                }
                return next(req);
            },
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * The programmatic identifier of the bearerTokenAuthenticationPolicy.
     */
    const keyCredentialAuthenticationPolicyName = "keyCredentialAuthenticationPolicy";
    function keyCredentialAuthenticationPolicy(credential, apiKeyHeaderName) {
        return {
            name: keyCredentialAuthenticationPolicyName,
            async sendRequest(request, next) {
                request.headers.set(apiKeyHeaderName, credential.key);
                return next(request);
            },
        };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    let cachedHttpClient;
    /**
     * Adds a credential policy to the pipeline if a credential is provided. If none is provided, no policy is added.
     */
    function addCredentialPipelinePolicy(pipeline, endpoint, options = {}) {
        var _a, _b, _c, _d;
        const { credential, clientOptions } = options;
        if (!credential) {
            return;
        }
        if (isTokenCredential$1(credential)) {
            const tokenPolicy = bearerTokenAuthenticationPolicy({
                credential,
                scopes: (_b = (_a = clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.credentials) === null || _a === void 0 ? void 0 : _a.scopes) !== null && _b !== void 0 ? _b : `${endpoint}/.default`,
            });
            pipeline.addPolicy(tokenPolicy);
        }
        else if (isKeyCredential(credential)) {
            if (!((_c = clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.credentials) === null || _c === void 0 ? void 0 : _c.apiKeyHeaderName)) {
                throw new Error(`Missing API Key Header Name`);
            }
            const keyPolicy = keyCredentialAuthenticationPolicy(credential, (_d = clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.credentials) === null || _d === void 0 ? void 0 : _d.apiKeyHeaderName);
            pipeline.addPolicy(keyPolicy);
        }
    }
    /**
     * Creates a default rest pipeline to re-use accross Rest Level Clients
     */
    function createDefaultPipeline(endpoint, credential, options = {}) {
        const pipeline = createPipelineFromOptions(options);
        pipeline.addPolicy(apiVersionPolicy(options));
        addCredentialPipelinePolicy(pipeline, endpoint, { credential, clientOptions: options });
        return pipeline;
    }
    function getCachedDefaultHttpsClient() {
        if (!cachedHttpClient) {
            cachedHttpClient = createDefaultHttpClient();
        }
        return cachedHttpClient;
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Get value of a header in the part descriptor ignoring case
     */
    function getHeaderValue(descriptor, headerName) {
        if (descriptor.headers) {
            const actualHeaderName = Object.keys(descriptor.headers).find((x) => x.toLowerCase() === headerName.toLowerCase());
            if (actualHeaderName) {
                return descriptor.headers[actualHeaderName];
            }
        }
        return undefined;
    }
    function getPartContentType(descriptor) {
        const contentTypeHeader = getHeaderValue(descriptor, "content-type");
        if (contentTypeHeader) {
            return contentTypeHeader;
        }
        // Special value of null means content type is to be omitted
        if (descriptor.contentType === null) {
            return undefined;
        }
        if (descriptor.contentType) {
            return descriptor.contentType;
        }
        const { body } = descriptor;
        if (body === null || body === undefined) {
            return undefined;
        }
        if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
            return "text/plain; charset=UTF-8";
        }
        if (body instanceof Blob) {
            return body.type || "application/octet-stream";
        }
        if (isBinaryBody(body)) {
            return "application/octet-stream";
        }
        // arbitrary non-text object -> generic JSON content type by default. We will try to JSON.stringify the body.
        return "application/json; charset=UTF-8";
    }
    /**
     * Enclose value in quotes and escape special characters, for use in the Content-Disposition header
     */
    function escapeDispositionField(value) {
        return JSON.stringify(value);
    }
    function getContentDisposition(descriptor) {
        var _a;
        const contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
        if (contentDispositionHeader) {
            return contentDispositionHeader;
        }
        if (descriptor.dispositionType === undefined &&
            descriptor.name === undefined &&
            descriptor.filename === undefined) {
            return undefined;
        }
        const dispositionType = (_a = descriptor.dispositionType) !== null && _a !== void 0 ? _a : "form-data";
        let disposition = dispositionType;
        if (descriptor.name) {
            disposition += `; name=${escapeDispositionField(descriptor.name)}`;
        }
        let filename = undefined;
        if (descriptor.filename) {
            filename = descriptor.filename;
        }
        else if (typeof File !== "undefined" && descriptor.body instanceof File) {
            const filenameFromFile = descriptor.body.name;
            if (filenameFromFile !== "") {
                filename = filenameFromFile;
            }
        }
        if (filename) {
            disposition += `; filename=${escapeDispositionField(filename)}`;
        }
        return disposition;
    }
    function normalizeBody(body, contentType) {
        if (body === undefined) {
            // zero-length body
            return new Uint8Array([]);
        }
        // binary and primitives should go straight on the wire regardless of content type
        if (isBinaryBody(body)) {
            return body;
        }
        if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
            return stringToUint8Array(String(body), "utf-8");
        }
        // stringify objects for JSON-ish content types e.g. application/json, application/merge-patch+json, application/vnd.oci.manifest.v1+json, application.json; charset=UTF-8
        if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) {
            return stringToUint8Array(JSON.stringify(body), "utf-8");
        }
        throw new RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
    }
    function buildBodyPart(descriptor) {
        var _a;
        const contentType = getPartContentType(descriptor);
        const contentDisposition = getContentDisposition(descriptor);
        const headers = createHttpHeaders((_a = descriptor.headers) !== null && _a !== void 0 ? _a : {});
        if (contentType) {
            headers.set("content-type", contentType);
        }
        if (contentDisposition) {
            headers.set("content-disposition", contentDisposition);
        }
        const body = normalizeBody(descriptor.body, contentType);
        return {
            headers,
            body,
        };
    }
    function buildMultipartBody(parts) {
        return { parts: parts.map(buildBodyPart) };
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Helper function to send request used by the client
     * @param method - method to use to send the request
     * @param url - url to send the request to
     * @param pipeline - pipeline with the policies to run when sending the request
     * @param options - request options
     * @param customHttpClient - a custom HttpClient to use when making the request
     * @returns returns and HttpResponse
     */
    async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
        var _a;
        const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();
        const request = buildPipelineRequest(method, url, options);
        const response = await pipeline.sendRequest(httpClient, request);
        const headers = response.headers.toJSON();
        const stream = (_a = response.readableStreamBody) !== null && _a !== void 0 ? _a : response.browserStreamBody;
        const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);
        const body = stream !== null && stream !== void 0 ? stream : parsedBody;
        if (options === null || options === void 0 ? void 0 : options.onResponse) {
            options.onResponse(Object.assign(Object.assign({}, response), { request, rawHeaders: headers, parsedBody }));
        }
        return {
            request,
            headers,
            status: `${response.status}`,
            body,
        };
    }
    /**
     * Function to determine the request content type
     * @param options - request options InternalRequestParameters
     * @returns returns the content-type
     */
    function getRequestContentType(options = {}) {
        var _a, _b, _c;
        return ((_c = (_a = options.contentType) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b["content-type"]) !== null && _c !== void 0 ? _c : getContentType(options.body));
    }
    /**
     * Function to determine the content-type of a body
     * this is used if an explicit content-type is not provided
     * @param body - body in the request
     * @returns returns the content-type
     */
    function getContentType(body) {
        if (ArrayBuffer.isView(body)) {
            return "application/octet-stream";
        }
        if (typeof body === "string") {
            try {
                JSON.parse(body);
                return "application/json; charset=UTF-8";
            }
            catch (error) {
                // If we fail to parse the body, it is not json
                return undefined;
            }
        }
        // By default return json
        return "application/json; charset=UTF-8";
    }
    function buildPipelineRequest(method, url, options = {}) {
        var _a, _b, _c;
        const requestContentType = getRequestContentType(options);
        const { body, multipartBody } = getRequestBody(options.body, requestContentType);
        const hasContent = body !== undefined || multipartBody !== undefined;
        const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, (options.headers ? options.headers : {})), { accept: (_c = (_a = options.accept) !== null && _a !== void 0 ? _a : (_b = options.headers) === null || _b === void 0 ? void 0 : _b.accept) !== null && _c !== void 0 ? _c : "application/json" }), (hasContent &&
            requestContentType && {
            "content-type": requestContentType,
        })));
        return createPipelineRequest({
            url,
            method,
            body,
            multipartBody,
            headers,
            allowInsecureConnection: options.allowInsecureConnection,
            tracingOptions: options.tracingOptions,
            abortSignal: options.abortSignal,
            onUploadProgress: options.onUploadProgress,
            onDownloadProgress: options.onDownloadProgress,
            timeout: options.timeout,
            enableBrowserStreams: true,
            streamResponseStatusCodes: options.responseAsStream
                ? new Set([Number.POSITIVE_INFINITY])
                : undefined,
        });
    }
    /**
     * Prepares the body before sending the request
     */
    function getRequestBody(body, contentType = "") {
        if (body === undefined) {
            return { body: undefined };
        }
        if (typeof FormData !== "undefined" && body instanceof FormData) {
            return { body };
        }
        if (isReadableStream(body)) {
            return { body };
        }
        const firstType = contentType.split(";")[0];
        if (firstType === "application/json") {
            return { body: JSON.stringify(body) };
        }
        if (ArrayBuffer.isView(body)) {
            return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
        }
        switch (firstType) {
            case "multipart/form-data":
                if (Array.isArray(body)) {
                    return { multipartBody: buildMultipartBody(body) };
                }
                return { body: JSON.stringify(body) };
            case "text/plain":
                return { body: String(body) };
            default:
                if (typeof body === "string") {
                    return { body };
                }
                return { body: JSON.stringify(body) };
        }
    }
    /**
     * Prepares the response body
     */
    function getResponseBody(response) {
        var _a, _b;
        // Set the default response type
        const contentType = (_a = response.headers.get("content-type")) !== null && _a !== void 0 ? _a : "";
        const firstType = contentType.split(";")[0];
        const bodyToParse = (_b = response.bodyAsText) !== null && _b !== void 0 ? _b : "";
        if (firstType === "text/plain") {
            return String(bodyToParse);
        }
        // Default to "application/json" and fallback to string;
        try {
            return bodyToParse ? JSON.parse(bodyToParse) : undefined;
        }
        catch (error) {
            // If we were supposed to get a JSON object and failed to
            // parse, throw a parse error
            if (firstType === "application/json") {
                throw createParseError(response, error);
            }
            // We are not sure how to handle the response so we return it as
            // plain text.
            return String(bodyToParse);
        }
    }
    function createParseError(response, err) {
        var _a;
        const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
        const errCode = (_a = err.code) !== null && _a !== void 0 ? _a : RestError.PARSE_ERROR;
        return new RestError(msg, {
            code: errCode,
            statusCode: response.status,
            request: response.request,
            response: response,
        });
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Builds the request url, filling in query and path parameters
     * @param endpoint - base url which can be a template url
     * @param routePath - path to append to the endpoint
     * @param pathParameters - values of the path parameters
     * @param options - request parameters including query parameters
     * @returns a full url with path and query parameters
     */
    function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {
        if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
            return routePath;
        }
        endpoint = buildBaseUrl(endpoint, options);
        routePath = buildRoutePath(routePath, pathParameters, options);
        const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);
        const url = new URL(requestUrl);
        return (url
            .toString()
            // Remove double forward slashes
            .replace(/([^:]\/)\/+/g, "$1"));
    }
    function appendQueryParams(url, options = {}) {
        if (!options.queryParameters) {
            return url;
        }
        let parsedUrl = new URL(url);
        const queryParams = options.queryParameters;
        for (const key of Object.keys(queryParams)) {
            const param = queryParams[key];
            if (param === undefined || param === null) {
                continue;
            }
            if (!param.toString || typeof param.toString !== "function") {
                throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
            }
            const value = param.toISOString !== undefined ? param.toISOString() : param.toString();
            parsedUrl.searchParams.append(key, value);
        }
        if (options.skipUrlEncoding) {
            parsedUrl = skipQueryParameterEncoding(parsedUrl);
        }
        return parsedUrl.toString();
    }
    function skipQueryParameterEncoding(url) {
        if (!url) {
            return url;
        }
        const searchPieces = [];
        for (const [name, value] of url.searchParams) {
            // QUIRK: searchParams.get retrieves the values decoded
            searchPieces.push(`${name}=${value}`);
        }
        // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.
        url.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
        return url;
    }
    function buildBaseUrl(endpoint, options) {
        var _a;
        if (!options.pathParameters) {
            return endpoint;
        }
        const pathParams = options.pathParameters;
        for (const [key, param] of Object.entries(pathParams)) {
            if (param === undefined || param === null) {
                throw new Error(`Path parameters ${key} must not be undefined or null`);
            }
            if (!param.toString || typeof param.toString !== "function") {
                throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
            }
            let value = param.toISOString !== undefined ? param.toISOString() : String(param);
            if (!options.skipUrlEncoding) {
                value = encodeURIComponent(param);
            }
            endpoint = (_a = replaceAll(endpoint, `{${key}}`, value)) !== null && _a !== void 0 ? _a : "";
        }
        return endpoint;
    }
    function buildRoutePath(routePath, pathParameters, options = {}) {
        for (const pathParam of pathParameters) {
            let value = pathParam;
            if (!options.skipUrlEncoding) {
                value = encodeURIComponent(pathParam);
            }
            routePath = routePath.replace(/\{\w+\}/, value);
        }
        return routePath;
    }
    /**
     * Replace all of the instances of searchValue in value with the provided replaceValue.
     * @param value - The value to search and replace in.
     * @param searchValue - The value to search for in the value argument.
     * @param replaceValue - The value to replace searchValue with in the value argument.
     * @returns The value where each instance of searchValue was replaced with replacedValue.
     */
    function replaceAll(value, searchValue, replaceValue) {
        return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    function getClient(endpoint, credentialsOrPipelineOptions, clientOptions = {}) {
        var _a;
        let credentials;
        if (credentialsOrPipelineOptions) {
            if (isCredential$1(credentialsOrPipelineOptions)) {
                credentials = credentialsOrPipelineOptions;
            }
            else {
                clientOptions = credentialsOrPipelineOptions !== null && credentialsOrPipelineOptions !== void 0 ? credentialsOrPipelineOptions : {};
            }
        }
        const pipeline = createDefaultPipeline(endpoint, credentials, clientOptions);
        if ((_a = clientOptions.additionalPolicies) === null || _a === void 0 ? void 0 : _a.length) {
            for (const { policy, position } of clientOptions.additionalPolicies) {
                // Sign happens after Retry and is commonly needed to occur
                // before policies that intercept post-retry.
                const afterPhase = position === "perRetry" ? "Sign" : undefined;
                pipeline.addPolicy(policy, {
                    afterPhase,
                });
            }
        }
        const { allowInsecureConnection, httpClient } = clientOptions;
        const client = (path, ...args) => {
            const getUrl = (requestOptions) => buildRequestUrl(endpoint, path, args, Object.assign({ allowInsecureConnection }, requestOptions));
            return {
                get: (requestOptions = {}) => {
                    return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
                },
                post: (requestOptions = {}) => {
                    return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
                },
                put: (requestOptions = {}) => {
                    return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
                },
                patch: (requestOptions = {}) => {
                    return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
                },
                delete: (requestOptions = {}) => {
                    return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
                },
                head: (requestOptions = {}) => {
                    return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
                },
                options: (requestOptions = {}) => {
                    return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
                },
                trace: (requestOptions = {}) => {
                    return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
                },
            };
        };
        return {
            path: client,
            pathUnchecked: client,
            pipeline,
        };
    }
    function buildOperation(method, url, pipeline, options, allowInsecureConnection, httpClient) {
        var _a;
        allowInsecureConnection = (_a = options.allowInsecureConnection) !== null && _a !== void 0 ? _a : allowInsecureConnection;
        return {
            then: function (onFulfilled, onrejected) {
                return sendRequest(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection }), httpClient).then(onFulfilled, onrejected);
            },
            async asBrowserStream() {
                return sendRequest(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection, responseAsStream: true }), httpClient);
            },
            async asNodeStream() {
                return sendRequest(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection, responseAsStream: true }), httpClient);
            },
        };
    }
    function isCredential$1(param) {
        return isKeyCredential(param) || isTokenCredential$1(param);
    }

    function isErrorResponse(response) {
        return (typeof response === "object" && response !== null && "error" in response);
    }

    function makeAsyncIterable(stream) {
        return {
            async *[Symbol.asyncIterator]() {
                const reader = stream.getReader();
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) {
                            return;
                        }
                        yield value;
                    }
                }
                finally {
                    const cancel = reader.cancel();
                    reader.releaseLock();
                    await cancel;
                }
            },
        };
    }
    async function* toLines(stream) {
        let ControlChar;
        (function (ControlChar) {
            ControlChar[ControlChar["LF"] = 10] = "LF";
            ControlChar[ControlChar["CR"] = 13] = "CR";
        })(ControlChar || (ControlChar = {}));
        let buf;
        let bufIndex = 0;
        const chunkIter = makeAsyncIterable(stream);
        for await (const chunk of chunkIter) {
            if (buf === undefined) {
                buf = chunk;
                bufIndex = 0;
            }
            else {
                buf = Uint8Array.from([...buf, ...chunk]);
            }
            const bufLen = buf.length;
            let start = 0;
            while (bufIndex < bufLen) {
                while (bufIndex < bufLen && buf[bufIndex] !== ControlChar.LF) {
                    bufIndex++;
                }
                if (bufIndex === bufLen) {
                    break;
                }
                if (bufIndex > 0 && buf[bufIndex - 1] === ControlChar.CR) {
                    if (start < bufIndex - 1) {
                        yield new TextDecoder().decode(buf.slice(start, bufIndex - 1));
                    }
                    start = bufIndex + 1;
                }
                else {
                    if (start < bufIndex) {
                        yield new TextDecoder().decode(buf.slice(start, bufIndex));
                    }
                    start = bufIndex + 1;
                }
                bufIndex++;
            }
            if (start < bufLen) {
                buf = buf.slice(start);
                bufIndex = buf.length;
            }
            else {
                buf = undefined;
            }
        }
    }
    async function* map(iter, fn) {
        for await (const value of iter) {
            yield fn(value);
        }
    }
    function getAsyncIterable(stream) {
        return map(toLines(stream), (line) => {
            const parsed = JSON.parse(line);
            if (isErrorResponse(parsed)) {
                throw parsed.error;
            }
            return parsed;
        });
    }

    function asStream(method) {
        return method.asBrowserStream();
    }

    function isAbsoluteUrl(url) {
        let parsed;
        try {
            parsed = new URL(url);
        }
        catch (e) {
            return false;
        }
        return parsed.protocol === "http:" || parsed.protocol === "https:";
    }
    function toAbsoluteUrl(url) {
        if (isAbsoluteUrl(url)) {
            return url;
        }
        const base = window.location.origin;
        const basePath = window.location.pathname;
        return new URL(url, `${base}${basePath}`).href;
    }

    function isTokenCredential(credential) {
        const castCredential = credential;
        return (castCredential &&
            typeof castCredential.getToken === "function" &&
            (castCredential.signRequest === undefined ||
                castCredential.getToken.length > 0));
    }
    function isCredential(credential) {
        return isTokenCredential(credential) || isKeyCredential(credential);
    }
    function isLocalhost(url) {
        const parsed = new URL(url);
        return parsed.hostname === "localhost" || parsed.hostname === "127.0.0.1";
    }
    async function getStreamContent(stream) {
        const bodyText = await new Response(stream).text();
        try {
            return JSON.parse(bodyText);
        }
        catch (error) {
            return bodyText;
        }
    }
    function handleFailedRequest(status, body) {
        if (isErrorResponse(body)) {
            throw body.error;
        }
        throw {
            code: status,
            message: `Request failed with status code ${status}`,
        };
    }
    function splitURL(url) {
        const parsed = new URL(url);
        return [parsed.origin, parsed.pathname];
    }
    class AIChatProtocolClient {
        client;
        basePath;
        constructor(endpoint, arg1, arg2) {
            const absoluteEndpoint = toAbsoluteUrl(endpoint);
            const [origin, basePath] = splitURL(absoluteEndpoint);
            this.basePath = basePath;
            const defaults = {
                allowInsecureConnection: isLocalhost(absoluteEndpoint),
            };
            if (isCredential(arg1)) {
                this.client = getClient(origin, arg1, { ...defaults, ...arg2 });
            }
            else {
                this.client = getClient(origin, { ...defaults, ...arg1 });
            }
        }
        async getCompletion(messages, options = {}) {
            const request = {
                headers: {
                    "Content-Type": "application/json",
                },
                body: {
                    messages: messages,
                    context: options.context,
                    sessionState: options.sessionState,
                },
            };
            const response = await this.client
                .path(this.basePath)
                .post(request, options);
            const { status, body } = response;
            if (!/2\d\d/.test(status)) {
                handleFailedRequest(status, body);
            }
            return body;
        }
        async getStreamedCompletion(messages, options = {}) {
            const request = {
                headers: {
                    "Content-Type": "application/json",
                },
                body: {
                    messages: messages,
                    context: options.context,
                    sessionState: options.sessionState,
                },
            };
            const response = await asStream(this.client.path(`${this.basePath}/stream`).post(request, options));
            if (!/2\d\d/.test(response.status)) {
                const body = await getStreamContent(response.body);
                handleFailedRequest(response.status, body);
            }
            return getAsyncIterable(response.body);
        }
    }

    exports.AIChatProtocolClient = AIChatProtocolClient;

    return exports;

})({});
//# sourceMappingURL=index.js.map
